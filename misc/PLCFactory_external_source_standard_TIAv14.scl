FUNCTION "UTIL_P_TRIG" : Void
TITLE = Positive Edge Detection Pulse
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      "i_Input Bit" : Bool;
   END_VAR

   VAR_IN_OUT 
      "iq_Trigger Bit" : Bool;
      "iq_Pulse Bit" : Bool;
   END_VAR

BEGIN
	//Prositive edge generator for SCL
	
	IF #"i_Input Bit" AND #"iq_Trigger Bit"
	THEN
	    #"iq_Pulse Bit" := FALSE;
	ELSIF #"i_Input Bit"
	    THEN
	        #"iq_Pulse Bit" := TRUE;
	        #"iq_Trigger Bit" := TRUE;
	    ELSE
	        #"iq_Pulse Bit" := FALSE;
	        #"iq_Trigger Bit" := FALSE;
	END_IF;
END_FUNCTION
FUNCTION_BLOCK "_UtilitiesFB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      CPUSytemMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of system memory byte
      CPUClockMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of clock memory byte
      StartupDelaySP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;   // Delay before startup delay bit turned on
   END_VAR

   VAR 
      AlwaysOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE for only the first scan of the PLC
      StartupDelayDn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit initially FALSE, turning TRUE after preset delay
      StartupDelayTmr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      Square_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (100 ms frequency)
      Square_100msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 100 ms for one PLC scan
      Square_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (200 ms frequency)
      Square_200msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 200 ms for one PLC scan
      Square_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (400 ms frequency)
      Square_400msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 400 ms for one PLC scan
      Square_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (500 ms frequency)
      Square_500msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 500 ms for one PLC scan
      Square_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (800 ms frequency)
      Square_800msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 800 ms for one PLC scan
      Square_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1 s frequency)
      Square_1sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1 s for one PLC scan
      Square_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1600 ms frequency)
      Square_1600msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1600 ms for one PLC scan
      Square_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (2 s frequency)
      Square_2sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 2 s for one PLC scan
      TestInProgress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Indicates which caller FC is used
   END_VAR

BEGIN
	//This block provides standard "Utilities" tags that can be used in the rest OF the PLC code such
	//as:
	//* Always On
	//* Always Off
	//* Startup Delay
	//* Pulses (different frequences)
	//* etc.
	
	//When using This block in your program, name the instance DB "Utilities" AND THEN you will be able TO use tags like "Utilities.AlwaysOn" in the rest OF your program.
	
	//This block relies On information provided BY the CPU. This needs TO be enabled in the CPU hardware configuration under System AND Clock Memory.
	//Enable both functions AND pick memory bytes you'd like TO use (defauls are %MB1 AND %MB0 respectively).
	//THEN connect the selected Byte TO the inputs OF This block.
	//
	
	//Bit TRUE for only the first scan of the PLC
	#FirstScan := #CPUSytemMemoryBits.%X0;
	
	//Bit always TRUE
	#AlwaysOn := #CPUSytemMemoryBits.%X2;
	#AlwaysTrue := #CPUSytemMemoryBits.%X2;
	
	//Bit always FALSE
	#AlwaysOff := #CPUSytemMemoryBits.%X3;
	#AlwaysFalse := #CPUSytemMemoryBits.%X3;
	
	//Bit initially FALSE, turning TRUE after preset delay
	#StartupDelayTmr.TON(IN := #AlwaysTrue,
	                     PT := #StartupDelaySP,
	                     Q => #StartupDelayDn);
	
	//Bit TRUE every 100 ms FOR one PLC scan
	#Square_100ms := #CPUClockMemoryBits.%X0;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_100ms,
	              "iq_Trigger Bit" := #Square_100msONS,
	              "iq_Pulse Bit" := #Pulse_100ms);
	
	//Bit TRUE every 200 ms FOR one PLC scan
	#Square_200ms := #CPUClockMemoryBits.%X1;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_200ms,
	              "iq_Trigger Bit" := #Square_200msONS,
	              "iq_Pulse Bit" := #Pulse_200ms);
	
	//Bit TRUE every 400 ms FOR one PLC scan
	#Square_400ms := #CPUClockMemoryBits.%X2;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_400ms,
	              "iq_Trigger Bit" := #Square_400msONS,
	              "iq_Pulse Bit" := #Pulse_400ms);
	
	//Bit TRUE every 500 ms FOR one PLC scan
	#Square_500ms := #CPUClockMemoryBits.%X3;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_500ms,
	              "iq_Trigger Bit" := #Square_500msONS,
	              "iq_Pulse Bit" := #Pulse_500ms);
	
	//Bit TRUE every 800 ms FOR one PLC scan
	#Square_800ms := #CPUClockMemoryBits.%X4;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_800ms,
	              "iq_Trigger Bit" := #Square_800msONS,
	              "iq_Pulse Bit" := #Pulse_800ms);
	
	//Bit TRUE every 1 s FOR one PLC scan
	#Square_1s := #CPUClockMemoryBits.%X5;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1s,
	              "iq_Trigger Bit" := #Square_1sONS,
	              "iq_Pulse Bit" := #Pulse_1s);
	
	//Bit TRUE every 1600 ms FOR one PLC scan
	#Square_1600ms := #CPUClockMemoryBits.%X6;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1600ms,
	              "iq_Trigger Bit" := #Square_1600msONS,
	              "iq_Pulse Bit" := #Pulse_1600ms);
	
	//Bit TRUE every 2s FOR one PLC scan
	#Square_2s := #CPUClockMemoryBits.%X7;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_2s,
	              "iq_Trigger Bit" := #Square_2sONS,
	              "iq_Pulse Bit" := #Pulse_2s);
	
END_FUNCTION_BLOCK
DATA_BLOCK "Utilities"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"_UtilitiesFB"

BEGIN

END_DATA_BLOCK
DATA_BLOCK "EPICSToPLC"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
//########## EPICS->PLC datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..10] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK	
DATA_BLOCK "PLCToEPICS"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
//########## PLC->EPICS datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..10] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK
FUNCTION_BLOCK "_CommsPLC_EPICS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Enable all comms
      SendTrigger { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Trigger for PLC->EPICS data send (should be quick and cyclic)
      BytesToSend { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Number of bytes for PLC->EPICS data send
      InterfaceID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : HW_ANY;   // Hardware identifier of Ethernet port to be used (see under device configuration)
      S7ConnectionID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int := 256;   // Connection ID for EPICS s7plc driver connection
      MBConnectionID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int := 255;   // Connection ID for EPICS modbus driver connection
      S7Port { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int := 2000;   // PLC port for EPICS s7plc driver connection
      MBPort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int := 502;   // PLC port for EPICS modbus driver connection
   END_VAR

   VAR_OUTPUT 
      SendDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      SendBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      SendError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      SendStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      RcvNewDataReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      RcvDataRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      RcvError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      RcvStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
   END_VAR

   VAR_IN_OUT 
      PLCToEPICSData : Variant;   // Pointer to PLC->EPICS data exchange block (header of the array of words)
      EPICSToPLCData : Variant;   // Pointer to EPICS->PLC data exchange block (header of the array of words)
   END_VAR

   VAR 
      SendConnData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4;   // Connection parameters
      RcvConnData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4;   // Connection parameters
      TSEND_C_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'TSENDC'; LibVersion := '3.2'} : TSEND_C;
      MB_SERVER_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'MBSERVER'; LibVersion := '4.2'} : MB_SERVER;
   END_VAR


BEGIN
	//This function block performs send/recieve communication between the PLC AND EPICS using:
	//1. Open user communication (s7plc driver in EPICS)
	//2. Modbus TCP (Modbus driver in EPICS)
	//
	//The block is fully self-contained, i.e. you should be able TO simple insert it in your program (AND call it OF course) AND provide some inputs TO it
	//
	
	//Set up connections (Ethernet port ID)
	#SendConnData.InterfaceId := #InterfaceID;
	#RcvConnData.InterfaceId := #InterfaceID;
	
	//Set up connections (Connection ID) (separate connections for s7 and Modbus)
	#SendConnData.ID := INT_TO_WORD(IN:= #S7ConnectionID);
	#RcvConnData.ID := INT_TO_WORD(IN := #MBConnectionID);
	
	//Set up connections (Connection type)
	#SendConnData.ConnectionType := 11;
	#RcvConnData.ConnectionType := 11;
	
	//Set up connections (Active connection establishment)
	IF NOT #SendConnData.ActiveEstablished THEN
	    #RcvConnData.ActiveEstablished := false;
	END_IF;
	
	//Set up connections (Local port)
	#SendConnData.LocalPort := INT_TO_UINT(IN:= #S7Port);
	#RcvConnData.LocalPort := INT_TO_UINT(IN := #MBPort);
	
	//PLC -> EPICS communication. Data is sent using open user communication (s7plc driver in EPICS)
	#TSEND_C_DB(REQ:=#SendTrigger,
	            CONT:=TRUE,
	            LEN:=INT_TO_UINT(IN:=#BytesToSend),
	            DONE=>#SendDone,
	            BUSY=>#SendBusy,
	            ERROR=>#SendError,
	            STATUS=>#SendStatus,
	            CONNECT:=#SendConnData,
	            DATA:=#PLCToEPICSData);
	
	//EPICS <- EPICS communication. Data is received using modbus server on the PLC (modbus driver in EPICS)
	#MB_SERVER_DB(DISCONNECT:=NOT #Enable,
	              NDR=>#RcvNewDataReady,
	              DR=>#RcvDataRead,
	              ERROR=>#RcvError,
	              STATUS=>#RcvStatus,
	              MB_HOLD_REG:=#EPICSToPLCData,
	              CONNECT:=#RcvConnData);
	
END_FUNCTION_BLOCK
DATA_BLOCK "_CommsPLC_EPICS_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"_CommsPLC_EPICS"

BEGIN

END_DATA_BLOCK
FUNCTION "_CommsEPICS" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//Heartbeat PLC->EPICS
	IF "Utilities".Pulse_1s THEN
	    "PLCToEPICS"."Word"[2] := "PLCToEPICS"."Word"[2] + 1;
	    IF "PLCToEPICS"."Word"[2] >= 32000 THEN
	        "PLCToEPICS"."Word"[2] := 0;
	    END_IF;
	END_IF;
	
	// Call the comms block to provide PLC<->EPICS comms
	"_CommsPLC_EPICS_DB"(Enable := "Utilities".AlwaysOn,
	                     SendTrigger := "Utilities".Pulse_200ms,
	                     BytesToSend := 10,
	                     InterfaceID := 64,
	                     S7ConnectionID := 256,
	                     MBConnectionID := 255,
	                     S7Port := 2000,
	                     MBPort := 502,
	                     PLCToEPICSData := "PLCToEPICS"."Word",
	                     EPICSToPLCData := "EPICSToPLC"."Word");
	
	
END_FUNCTION
FUNCTION "_Comms" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//This is an aggregator function, it will call all the other comms functions required:
	//1. PLC/EPICS
	//2. Any other comms
	
	"_CommsEPICS"();
	
END_FUNCTION
